package com.glyzier.service;

import com.glyzier.config.SupabaseConfig;
import com.glyzier.model.ProductFiles;
import com.glyzier.model.Products;
import com.glyzier.repository.ProductFilesRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;

import java.util.*;

/**
 * File Storage Service
 * 
 * Manages file upload, retrieval, and deletion operations with Supabase Storage.
 * Handles three storage buckets:
 * - product-images: Public gallery photos
 * - product-previews: Public thumbnail images
 * - digital-products: Private downloadable files (ZIP, PDF, etc.)
 * 
 * File Naming Strategy:
 * - Format: <productId>/<uuid>.<extension>
 * - Example: 42/a1b2c3d4-e5f6-7890.jpg
 * - Prevents naming conflicts and allows easy cleanup
 * 
 * Security:
 * - Public buckets: Direct URL access (images, previews)
 * - Private buckets: Signed URLs with 1-hour expiration (digital downloads)
 * - File type validation before upload
 * - File size limits enforced
 * 
 * @author Glyzier Development Team
 * @since Module 20 - Supabase Storage Integration
 */
@Service
public class FileStorageService {

    @Autowired
    private SupabaseConfig supabaseConfig;

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private ProductFilesRepository productFilesRepository;

    /**
     * Upload File to Supabase Storage
     * 
     * Uploads file to appropriate bucket based on file type.
     * Creates ProductFiles record in database after successful upload.
     * 
     * File Type to Bucket Mapping:
     * - product_image -> product-images bucket
     * - preview -> product-previews bucket
     * - digital_download -> digital-products bucket
     * 
     * @param file MultipartFile from upload request
     * @param product Product entity to associate file with
     * @param fileType File type enum (product_image, preview, digital_download)
     * @return ProductFiles entity with storage details
     * @throws IllegalArgumentException if upload fails or validation fails
     */
    public ProductFiles uploadFile(MultipartFile file, Products product, String fileType) 
            throws IllegalArgumentException {
        
        // Validate file
        validateFile(file, fileType);
        
        // Determine bucket based on file type
        String bucketName = getBucketForFileType(fileType);
        
        // Generate unique file key
        String fileKey = generateFileKey(product.getPid(), file.getOriginalFilename());
        
        // Upload to Supabase Storage
        uploadToSupabase(file, bucketName, fileKey);
        
        // Create database record
        ProductFiles productFile = new ProductFiles();
        productFile.setProduct(product);
        productFile.setFileType(fileType);
        productFile.setFileKey(fileKey);
        // Note: fileUrl is generated from fileKey when needed, not stored in database
        // createdAt is auto-generated by @CreationTimestamp annotation
        
        return productFilesRepository.save(productFile);
    }

    /**
     * Upload to Supabase Storage Bucket
     * 
     * Makes HTTP POST request to Supabase Storage REST API.
     * Uploads file bytes to specified bucket with authentication.
     * 
     * API Endpoint: POST /storage/v1/object/{bucket}/{path}
     * Headers:
     * - Authorization: Bearer {supabase-key}
     * - Content-Type: {file-mime-type}
     * 
     * @param file MultipartFile to upload
     * @param bucketName Target bucket name
     * @param fileKey Unique file path within bucket
     * @return Public URL for accessing the file
     * @throws IllegalArgumentException if upload fails
     */
    private String uploadToSupabase(MultipartFile file, String bucketName, String fileKey) {
        try {
            // Construct upload endpoint
            String uploadUrl = supabaseConfig.getStorageEndpoint(bucketName) + "/" + fileKey;
            
            // Prepare headers
            HttpHeaders headers = new HttpHeaders();
            headers.set("Authorization", "Bearer " + supabaseConfig.getSupabaseKey());
            headers.set("apikey", supabaseConfig.getSupabaseKey());
            headers.setContentType(MediaType.parseMediaType(file.getContentType()));
            
            // Create request entity with file bytes
            HttpEntity<byte[]> requestEntity = new HttpEntity<>(file.getBytes(), headers);
            
            // Upload file
            @SuppressWarnings("rawtypes")
            ResponseEntity<Map> response = restTemplate.exchange(
                uploadUrl,
                HttpMethod.POST,
                requestEntity,
                Map.class
            );
            
            if (response.getStatusCode() == HttpStatus.OK || 
                response.getStatusCode() == HttpStatus.CREATED) {
                
                // Return public URL for the file
                return supabaseConfig.getPublicUrl(bucketName, fileKey);
            } else {
                throw new IllegalArgumentException("Upload failed with status: " + response.getStatusCode());
            }
            
        } catch (Exception e) {
            throw new IllegalArgumentException("Failed to upload file to Supabase: " + e.getMessage());
        }
    }

    /**
     * Generate Signed URL for Private Files
     * 
     * Creates time-limited download URL for files in private buckets.
     * Used for digital product downloads (requires purchase verification).
     * 
     * Signed URL Expiration: 1 hour (3600 seconds)
     * 
     * API Endpoint: POST /storage/v1/object/sign/{bucket}/{path}
     * Request Body: { "expiresIn": 3600 }
     * 
     * @param fileKey File path in private bucket
     * @return Signed URL valid for 1 hour
     * @throws IllegalArgumentException if URL generation fails
     */
    public String generateSignedUrl(String fileKey, String fileType) throws IllegalArgumentException {
        try {
            // Get bucket name based on file type
            String bucketName = getBucketForFileType(fileType);
            
            // fileKey is already in format: productId/uuid.ext
            String filePath = fileKey;
            
            // Debug logging
            System.out.println("[SIGNED URL] FileKey: " + fileKey);
            System.out.println("[SIGNED URL] FileType: " + fileType);
            System.out.println("[SIGNED URL] Bucket: " + bucketName);
            System.out.println("[SIGNED URL] Full path: " + bucketName + "/" + filePath);
            
            // Construct sign endpoint - use bucket name only in URL, path goes in body
            String signUrl = supabaseConfig.getStorageUrl() + "/object/sign/" + bucketName;
            System.out.println("[SIGNED URL] Sign URL: " + signUrl);
            
            // Prepare headers
            HttpHeaders headers = new HttpHeaders();
            headers.set("Authorization", "Bearer " + supabaseConfig.getSupabaseKey());
            headers.set("apikey", supabaseConfig.getSupabaseKey());
            headers.setContentType(MediaType.APPLICATION_JSON);
            
            // Request body with paths array and expiration time
            Map<String, Object> body = new HashMap<>();
            body.put("expiresIn", 3600);
            body.put("paths", new String[]{filePath});
            System.out.println("[SIGNED URL] Request body paths: [" + filePath + "]");
            
            HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(body, headers);
            
            // Generate signed URL - use String response type for flexibility
            ResponseEntity<String> response = restTemplate.exchange(
                signUrl,
                HttpMethod.POST,
                requestEntity,
                String.class
            );
            
            if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {
                // Parse JSON response
                String responseBody = response.getBody();
                System.out.println("[SIGNED URL] Response: " + responseBody);
                
                // Check for error in response
                if (responseBody.contains("\"error\"") || responseBody.contains("\"message\"")) {
                    // Extract error message
                    String errorMsg = responseBody;
                    if (responseBody.contains("\"message\":\"")) {
                        int msgStart = responseBody.indexOf("\"message\":\"") + 11;
                        int msgEnd = responseBody.indexOf("\"", msgStart);
                        errorMsg = responseBody.substring(msgStart, msgEnd);
                    }
                    throw new IllegalArgumentException("Supabase error: " + errorMsg);
                }
                
                // Extract signedURL from response - handle both single and array formats
                if (responseBody.contains("signedURLs")) {
                    // Array format: {"signedURLs": [{"signedURL": "/path", "path": "..."}]}
                    int signedUrlStart = responseBody.indexOf("\"signedURL\":\"") + 13;
                    if (signedUrlStart > 12) {
                        int signedUrlEnd = responseBody.indexOf("\"", signedUrlStart);
                        if (signedUrlEnd > signedUrlStart) {
                            String signedPath = responseBody.substring(signedUrlStart, signedUrlEnd);
                            String fullUrl = supabaseConfig.getSupabaseUrl() + signedPath;
                            System.out.println("[SIGNED URL] Final URL: " + fullUrl);
                            return fullUrl;
                        }
                    }
                } else if (responseBody.contains("signedURL")) {
                    // Single format: {"signedURL": "/path"}
                    int signedUrlStart = responseBody.indexOf("\"signedURL\":\"") + 13;
                    if (signedUrlStart > 12) {
                        int signedUrlEnd = responseBody.indexOf("\"", signedUrlStart);
                        if (signedUrlEnd > signedUrlStart) {
                            String signedPath = responseBody.substring(signedUrlStart, signedUrlEnd);
                            String fullUrl = supabaseConfig.getSupabaseUrl() + signedPath;
                            System.out.println("[SIGNED URL] Final URL: " + fullUrl);
                            return fullUrl;
                        }
                    }
                }
                throw new IllegalArgumentException("No signed URL in response: " + responseBody);
            } else {
                throw new IllegalArgumentException("Failed to generate signed URL: HTTP " + response.getStatusCode());
            }
            
        } catch (Exception e) {
            throw new IllegalArgumentException("Failed to generate signed URL: " + e.getMessage());
        }
    }

    /**
     * Delete File from Supabase Storage
     * 
     * Removes file from storage bucket and deletes database record.
     * Called when user deletes product image or product itself is deleted.
     * 
     * API Endpoint: DELETE /storage/v1/object/{bucket}/{path}
     * 
     * @param fileId ProductFiles entity ID
     * @throws IllegalArgumentException if deletion fails
     */
    public void deleteFile(Long fileId) throws IllegalArgumentException {
        try {
            // Fetch file record
            ProductFiles file = productFilesRepository.findById(fileId)
                .orElseThrow(() -> new IllegalArgumentException("File not found"));
            
            String fileKey = file.getFileKey();
            String bucketName = getBucketForFileType(file.getFileType());
            
            // Construct delete endpoint
            String deleteUrl = supabaseConfig.getStorageEndpoint(bucketName) + "/" + fileKey;
            
            // Prepare headers
            HttpHeaders headers = new HttpHeaders();
            headers.set("Authorization", "Bearer " + supabaseConfig.getSupabaseKey());
            headers.set("apikey", supabaseConfig.getSupabaseKey());
            
            HttpEntity<Void> requestEntity = new HttpEntity<>(headers);
            
            // Delete file from storage
            ResponseEntity<Void> response = restTemplate.exchange(
                deleteUrl,
                HttpMethod.DELETE,
                requestEntity,
                Void.class
            );
            
            if (response.getStatusCode() == HttpStatus.OK || 
                response.getStatusCode() == HttpStatus.NO_CONTENT) {
                
                // Delete database record
                productFilesRepository.delete(file);
            } else {
                throw new IllegalArgumentException("Delete failed with status: " + response.getStatusCode());
            }
            
        } catch (Exception e) {
            throw new IllegalArgumentException("Failed to delete file: " + e.getMessage());
        }
    }

    /**
     * Get Files by Product
     * 
     * Retrieves all files associated with a product.
     * Used in product detail pages to display gallery and download links.
     * 
     * @param productId Product ID to fetch files for
     * @return List of ProductFiles entities
     */
    public List<ProductFiles> getProductFiles(Long productId) {
        return productFilesRepository.findByProductPid(productId);
    }

    /**
     * Get Files by Product and Type
     * 
     * Retrieves files filtered by type (product_image, preview, digital_download).
     * Used to fetch specific file categories.
     * 
     * @param productId Product ID
     * @param fileType File type to filter by
     * @return List of ProductFiles matching the type
     */
    public List<ProductFiles> getProductFilesByType(Long productId, String fileType) {
        return productFilesRepository.findByProductPidAndFileType(productId, fileType);
    }

    // ======================================
    // Helper Methods
    // ======================================

    /**
     * Validate Uploaded File
     * 
     * Checks file size, type, and count limits before upload.
     * Throws exception if validation fails.
     * 
     * Validation Rules:
     * - File must not be empty
     * - File size must not exceed max limit
     * - File type must be in allowed list
     * - File count must not exceed type limit
     * 
     * @param file MultipartFile to validate
     * @param fileType File type (product_image, preview, digital_download)
     * @throws IllegalArgumentException if validation fails
     */
    private void validateFile(MultipartFile file, String fileType) {
        // Check if file is empty
        if (file.isEmpty()) {
            throw new IllegalArgumentException("File is empty");
        }
        
        // Check file size
        long maxSize = supabaseConfig.getMaxFileSizeBytes();
        if (file.getSize() > maxSize) {
            throw new IllegalArgumentException("File size exceeds limit of " + supabaseConfig.getMaxFileSize());
        }
        
        // Check file type
        String contentType = file.getContentType();
        if (!supabaseConfig.isAllowedFileType(contentType)) {
            throw new IllegalArgumentException("File type not allowed: " + contentType);
        }
    }

    /**
     * Get Bucket Name for File Type
     * 
     * Maps file type enum to corresponding Supabase bucket.
     * 
     * @param fileType File type enum value
     * @return Bucket name string
     */
    private String getBucketForFileType(String fileType) {
        return switch (fileType.toLowerCase()) {
            case "product_image" -> supabaseConfig.getImagesBucketName();
            case "preview" -> supabaseConfig.getPreviewsBucketName();
            case "digital_download" -> supabaseConfig.getDigitalBucketName();
            default -> throw new IllegalArgumentException("Invalid file type: " + fileType);
        };
    }

    /**
     * Generate Unique File Key
     * 
     * Creates unique storage path for file in bucket.
     * Format: <productId>/<uuid>.<extension>
     * 
     * Example: 42/a1b2c3d4-e5f6-7890.jpg
     * 
     * @param productId Product ID for path prefix
     * @param originalFilename Original filename with extension
     * @return Unique file key for storage
     */
    private String generateFileKey(Long productId, String originalFilename) {
        String uuid = UUID.randomUUID().toString();
        String extension = getFileExtension(originalFilename);
        return productId + "/" + uuid + (extension.isEmpty() ? "" : "." + extension);
    }

    /**
     * Extract File Extension
     * 
     * Gets file extension from filename (e.g., "jpg", "png", "zip").
     * Returns empty string if no extension found.
     * 
     * @param filename Original filename
     * @return File extension without dot
     */
    private String getFileExtension(String filename) {
        if (filename == null || !filename.contains(".")) {
            return "";
        }
        return filename.substring(filename.lastIndexOf(".") + 1);
    }
}
